PageHeader(Page头部信息结构体)


typedef struct PageHeaderData
{
    /* XXX LSN is member of *any* block, not only page-organized ones */
    /* 
       日志文件信息，保存了该页面最后一次被修改的操作对应到确切的日志文件
       位置，包括了日志文件ID和日志文件偏移量
    */
    
    //pd_lsn、pd_tli记录日志相关的信息
    XLogRecPtr    pd_lsn;            /* LSN: next byte after last byte of xlog
                                 * record for last change to this page */
    uint16        pd_tli;            /* least significant bits of the TimeLineID
                                     * containing the LSN */
                                     
    /* 用来表示页面状态 */
    uint16         pd_flags;        /* flag bits, see below */
    
    /* 空闲空间起始位置，随着插入和删除操作位置发生变化。初始化时就是pd_linp的偏移位置 */
    LocationIndex pd_lower;        /* offset to start of free space */
    
    /* 空闲空间结束位置，随着插入和删除操作位置发生变化。初始化时与pd_special相同 */
    LocationIndex pd_upper;        /* offset to end of free space */
    
    /* 特殊用途空间的起始位置，结束位置是page尾部，直到页面结束 */
    LocationIndex pd_special;    /* offset to start of special space */
    //相当于画了一条线，从pd_special这个位置到page的结尾，都是special的地盘，普通插入Tuple，都不许进入这个私有地盘。而且这个pd_special一旦初始化之后，这个值就不会动了
    
    /* 高位字节表示page大小 */
    uint16        pd_pagesize_version;
    
    /* 页面类型： 有多种控制页面类型和数据页面 */   
    uint8          pd_type;
    
    /* 物理存储与逻辑存储的关联对象的OID */ 
    Oid            pd_oid;            /* oid of related object,
                                 * pg_class.oid for IAM, pg_class.relfilenode for others */
                                 
    /* 数据开始位置 */
    ItemIdData    pd_linp[1];        /* beginning of line pointer array */
    
} PageHeaderData;

宏PageSetPageSizeAndVersion用于设置大小和版本。
宏PageGetPageSize()获取Page大小。
宏PageGetPageLayoutVersion()获取版本号。
对应的实现：
#define PageSetPageSizeAndVersion(page, size, version) \
( \
    AssertMacro(((size) & 0xFF00) == (size)), \
    AssertMacro(((version) & 0x00FF) == (version)), \
    ((PageHeader) (page))->pd_pagesize_version = (size) | (version) \
)
#define PageGetPageSize(page) \
    ((Size) (((PageHeader) (page))->pd_pagesize_version & (uint16) 0xFF00))
#define PageGetPageLayoutVersion(page) \
    (((PageHeader) (page))->pd_pagesize_version & 0x00FF)


pd_type的定义：

typedef enum PageType{
    P_TEMPDATA,
    P_HEAP,
    P_BTREE,
    P_HASH,
    P_GIN,
    P_GIST,
    P_SEQUENCE,
    P_GAM,
    P_PFS,
    P_SGAM,
    P_BCM,
    P_DCM,
    P_IAM,
    P_VM, /* vm page*/
    P_UNKNOWN,
}PageType;


Page初始化：
void PageInit(Page page, Size pageSize, Size specialSize, PageType type)
{
    PageHeader    p = (PageHeader) page;
    uint16        pd_flags = p->pd_flags;

    specialSize = MAXALIGN_DISK(specialSize);

    Assert(pageSize == BLCKSZ);
    Assert(pageSize > specialSize + SizeOfPageHeaderData);

    /* Make sure all fields of page are zero, as well as unused space 确保页面的所有字段均为零以及未使用的空间*/
    MemSet(p, 0, pageSize);

    /* p->pd_flags = 0;                        done by above MemSet */
    PageSetPageSizeAndVersion(page, pageSize, PG_PAGE_LAYOUT_VERSION);
    PageSetPageType(page, type);
    PageSetOid(page, InvalidOid); /* we will set it later for heap page 我们将在稍后为堆页面设置它*/
    
    /* Support the uniform store encryption engine 支持统一存储加密引擎 */
    p->pd_lower = SizeOfPageHeaderData;
    if ((pd_flags & PG_PAGE_ENCRYPTED) && !PageIsCtrlPage(page))
        p->pd_special = pageSize - specialSize -
                        G_EncryptData->block_key_num * (G_EncryptData->key_len + G_EncryptData->verify_len);
    else
        p->pd_special = pageSize - specialSize;
    p->pd_upper = p->pd_special;

    /*
     * Empty page is all visible. We must set PD_ALL_VISIBLE because 
     * recycled page's "visibility map bit" may be set before. (Recycled page -- 
     * means page was deallocated by Vacuum or something else, and then 
     * be allocated.)
     */
    PageSetAllVisible(p);
    if ((pd_flags & PG_PAGE_ENCRYPTED) && !PageIsCtrlPage(page))
        PageSetEncrypted(p);
}

Page有效性检查：
bool
PageHeaderIsValid(PageHeader page)
{
    char       *pagebytes;
    int            i;

    /* Check normal case 检查正常的情况下*/
    /* Support the uniform store encryption engine. 支持统一存储加密引擎*/
    if (PageGetPageSize(page) == BLCKSZ &&
        PageGetPageLayoutVersion(page) == PG_PAGE_LAYOUT_VERSION &&
        (page->pd_flags & ~PD_VALID_FLAG_BITS) == 0 &&
        page->pd_lower >= SizeOfPageHeaderData &&
        page->pd_lower <= page->pd_upper &&
        page->pd_upper <= page->pd_special &&
        (PageIsEncrypted(page) ?
            page->pd_special <= BLCKSZ - G_EncryptData->block_key_num * (G_EncryptData->key_len + G_EncryptData->verify_len) :
            page->pd_special <= BLCKSZ) &&
        page->pd_special == MAXALIGN_DISK(page->pd_special))
        return true;

    /* Check all-zeroes case 检查所有为0的情况*/
    pagebytes = (char *) page;
    for (i = 0; i < BLCKSZ; i++)
    {
        /* Support the uniform store encryption engine. */
        if (pagebytes[i] != 0 && pagebytes[i] != 2)
            return false;
    }
    
    return true;
}
